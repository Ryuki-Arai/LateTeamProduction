using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D))]
/// <summary>徘徊する敵の動きを制御するscript</summary>
public class NakaiEnemy : MonoBehaviour//辺りを見回すのはアニメーション内でコライダーの向きを変更すれば良い。
{
    [SerializeField,Tooltip("ナカイの動く速さ")]
    float _moveSpeed = 5f;
    [SerializeField,Header("目標との距離の余裕"),Tooltip("目標との距離の余裕")]
    float _pointDis = 0.5f;
    [Tooltip("ナカイの動きが変わる時のステージのレベル")]
    int _stageLevelBorder = 0;
    [Tooltip("受け取ったpointの要素番号")]
    int _pointArrayNumber = 0;
    [SerializeField, Tooltip("playerを見つけたときTrue、Trueの時にはナカイは動かない")]
    bool _playerFind = false;
    [SerializeField,Tooltip("受け取ったステージのレベルが_stageLevelBorder以上ならTrue")]
    bool _levelBorder = false;
    [Tooltip("アニメーションイベント用,徘徊アニメーションが一周したらtrue")]
    bool _lookAround = false;
    [Tooltip("外部から受け取る、徘徊する位置情報")]
    Transform[] _points = null;
    [Tooltip("移動方向への速度計算結果")]
    Vector2 _dir = default;
    [Tooltip("動かなくなった時の最後に進んでいた方向")]
    Vector2 _lastMoveVelocity = default;
    Animator _anim = null;
    Rigidbody2D _rb = null;
    // Start is called before the first frame update
    void Start()
    {
        _rb = GetComponent<Rigidbody2D>();
        _anim = GetComponent<Animator>();
    }

    // Update is called once per frame
    void Update()
    {
        VelocitySave(_rb.velocity);
        if (_points != null)//ポイントを受け取っている
        {
            if (!_playerFind)//プレイヤーを見つけていない
            {
                if (!_levelBorder)//見渡す処理をする必要がないステージのレベルじゃなかった場合
                {
                    GotoPoint(_points);
                }
                else if(_levelBorder && !_lookAround)//見渡す処理をする必要があるステージのレベルだが、歩いている時
                {
                    GotoPoint(_points);
                }
            }
        }
    }
    private void LateUpdate()
    {
        if (!_anim)
            return;
        _anim.SetFloat("lastVeloX", Mathf.Abs(_lastMoveVelocity.x));//のちに名前を決める
        _anim.SetFloat("lastVeloY", Mathf.Abs(_lastMoveVelocity.y));
        _anim.SetBool("levelBorder", _levelBorder);
        _anim.SetBool("lookAround", _lookAround);
    }
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.gameObject.CompareTag("Player"))
        {
            _playerFind = true;
            Debug.Log("プレイヤーを見つけました");
            collision.GetComponent<PlayerController>().PlayerFind();
        }
    }
    /// <summary>渡す側は順番に気を付けること</summary>
    /// <param name="pointsArray"></param>
    public void GetPoints(Transform[] pointsArray)
    {
        _points = new Transform[pointsArray.Length];
        for (int i = 0; i < _points.Length; i++)
        {
            _points[i] = pointsArray[i];
        }
    }
    public void GetPlayerLevel(int level)
    {
        _levelBorder = _stageLevelBorder <= level ? true : false; 
    }
    /// <summary>渡されたpoint順に進む</summary>
    /// <param name="pointsArray"></param>
    void GotoPoint(Transform[] pointsArray)
    {
        //自分自身とポイントの距離を求める
        float distance = Vector2.Distance(transform.position, pointsArray[pointsArray.Length % _pointArrayNumber].position);
        if (distance >= _pointDis)//距離がなくなる、到達するまで
        {
            _dir = (pointsArray[Mathf.Abs(pointsArray.Length % _pointArrayNumber)].position - transform.position).normalized * _moveSpeed;
            //方向を定める
            transform.Translate(_dir * Time.deltaTime);//一定の速さ
            _rb.velocity = _dir;
        }
        else//到達したら
        {
            //GameManagerの判定用変数で逆に回るようになった場合はarrayNumber--;にする。
            _pointArrayNumber++;
        }
    }
    public void LookAroundIsActive()//アニメーションイベント用
    {
        _lookAround = !_lookAround;
    }
    private void VelocitySave(Vector2 velo)
    {
        if (velo != Vector2.zero)
            _lastMoveVelocity = velo;
    }
}
